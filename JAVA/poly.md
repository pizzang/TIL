# 다형성

### 클래스 간의 형변환

"상속구조"일 경우에만 클래스간의 형변환이 가능하다



1. **UpCasting**
   - 자식타입 => 부모타입
   - 생략이 가능하다.
   - ex) 자식.부모메소드();

2. **DownCasting**
   - 부모타입 => 자식타입
   - 생략이 불가능하다.
   - ex) ((자식)부모).자식메소드();



**instanceof** 연산자 => true / false
현재 레퍼런스가 실질적으로 어떤 클래스 타입을 참조하는지 확인할 때 사용

```java
if(arr[i] instanceof printChild1) {
    ((Child1)arr[i]).printChild1();
}else {
    ((Child2)arr[i]).printChild2();
}
```



**동적바인딩**
프로그램 실행 되기 전에는 컴파일 되면서 정적바인딩(자료형의 메소드를 가리킴)
단, 실질적으로 참조하는 자식클래스에 행당 메소드가 오버라이딩 되어있다면 프로그램 실행 시 동적으로 그 자식클래스의 오버라이딩 된 메소드를 찾아서 실행

**오버라이딩 특징**
오버라이딩 개념이 적용된 메소드를 호출 시 원조메소드보다 새롭게 정의된 메소드가 우선순위가 높기 때문에 먼저 호출이 됨

객체 배열을 쓸 때 오버라이딩을 이용하면 굳이 강제 형변환을 안해도 됨!



### 다형성을 사용하는 이유

부모타입의 자료형으로 다양한 자식 객체들을 모두 다룰 수 있음

메소드의 갯수가 줄어듬
코드가 줄어듬
부모타입의 객체배열로 자식객체들 사용가능(반복문 사용가능)
소스코드가 줄어드니까 효율성이 높아진다









